Thus, for each order generated by the intelligent scheduling model, the application automatically collects the necessary real-time monitoring data and returns the appropriate results. Notably, in order to minimize as many inaccuracies as possible from the hydraulic model, the return value for any of the returned variables can be stated as## Lecture 10: Containers
### Exercise: Tracing
- 实现一个函数trace1，它的参数是一个函数而且返回一个带参数的函数并打印
    - → 输入参数
    - ← 返回参数

```python
def trace1(f):
	"""Return a function that takes a single argument, x, prints it,
	and computes and prints F(x), and returns the computed value."""
	def traced(x):
		print('->',x)
		r = f(x)
		print('<-', r)
		return r
return traced

# 其实就是装饰器了
@trace1
def square(x):
	return x**2
```

### Decorators

- Python 的一个特性 — 装饰器，可以理解为函数的函数，如果函数是一个对象的话我们可以对函数进行什么操作
- 形式

```python
@ATTR
def aFunc(...):
	...

# ATTR是等价于以下形式的表达式

def aFunc(...):
	...
aFunc = ATTR(aFunc)

```

装饰器更适合内部调用，对于`aFunc = ATTR(aFunc)`来说如果函数需要进行递归调用，那这句表达式其实只会执行一次，但是如果是装饰器的话则意味着它永远是该函数的一部分。

### Containers

```python
# 其实就是元组的实现？
def pair(a, b):
	"""Reture a value that represents the order pair of values (A, B)"""
	return lambda which: a if which == 0 else b

def left(p):
	"""Assuming P was created by pair(x, y), return the value x"""
	return p(0)
def right(p):
	"""Assuming P was created by pair(x, y), return the value y"""
	return p(1)

# 如果要设置元组的值呢

def set_left(p, v):
	"""Given that P represents the pair (x, y) , cause P to 
		represent (v, y),returning Nothing"""
		p(2,v)
def set_right(p, v):
	"""Given that P represents the pair (x, y) , cause P to 
		represent (x, v),returning Nothing"""
		p(3,v)

def pair(a, b):
	def pair_func(which, v=None):
		if which == 0:
			return a
		elif which == 1:
			return b
		elif which == 2:
			a = v
		else:
			b = v
	return pair_func

Traceback (most recent call last):
  File "<input>", line 1, in <module>
  File "<input>", line 4, in pair_func
UnboundLocalError: local variable 'a' referenced before assignment
```

直接这样运行会报错，因为局部遍历返回之前还没有被赋值，需要添加`Nonlocal`语句

### Nonlocal

- 声明局部变量的作用域在当前框架之外

```python
def pair(a, b):
	def pair_func(which, v=None):
		nonlocal a, b # 此时a和b也在pair_func的作用域里
		if which == 0:
			return a
		elif which == 1:
			return b
		elif which == 2:
			a = v
		else:
			b = v
	return pair_func

```

### Sequence

- Sequence代表有索引值的数据集合，因此我们可以通过索引调用
- 可以是有限集合，也可以是无限集合
- 可以是可编辑的，可以是不可编辑的
- 有索引的
- 可迭代的

## Lecture 11: Data Abstraction

### Modify Lists

```python
>>> L = [1, 2, 3, 4, 5]
>>> L[2] = 6 # 赋值
>>> L[1:3] = [9,8] 
>>> L[2:4] = [] # 删除元素 remove()
>>> L[1:1] = [2,3,4,5] # 插入元素 insert
>>> L[len(L):] = [10, 11] # appending
>>> L[0:0] = range(-3, 0) # prepending
```

### Philosophy

- 数据抽象类型代表一些数据类型和它对应的操作
- Constructors: 创建一个该类型的新对象
- Accessors: 返回该对象指定item的属性
- Mutators: 修改类型中对应的item

### Dictionaries

```python
state = {
				"mas":"more",
				"otor":"other"}

state['pavo'] # 会报错
state.get('pavo','defealt') # 可以为不存在的字段设置默认值
```

### Iteration

```python
insect = {"spider":8, "centipedes":100, "bees":19}
for i in insect: # 默认迭代insect.keys()
	print(insect[name])
```

### Matrices

- A list of lists

```python
def matrix(rows, columns): # 如果使用元组将会无法修改
	return [[0 for i in range(rows)] for j in range(columns)]

def value(matrix, row, col):
	return matrix[row][col]
def set_value(matrix,row,column,val):
	matrix[row][column] = val
```

### Trees

```python
### 数组-元组实现
def tree(label, children=[]):
	return (label, list(children or []))

def label(tree):
	return tree[0]

def children(tree):
	return tree[1]

t = tree(20, [tree(12,[tree(9),[tree(4), tree(4)]])])

### 字典实现
def tree(label, children=[]):
	return {"l":label, "c": children}

def label(tree):
	return tree["l"]

def children(tree):
	return tree["c"]
```

树是一种递归结构，因此需要采样递归式的算法去遍历它

### Tree processing: Counting leaves

- 计算叶子节点的数量

```python
def count_leaves(t):
	"""Return the number of leave nodes in T"""
	if is_leaf(t):
		return 1
	else:
		children_leaves = 0
		for c in children(t):
			children_leaves += count_leaves(c)
		return children_leaves 
```

### Tree creation: Doubling labels

```python
def is_leaf(t):
	return True if children(t) else False

def double(t):
	if is_leaf(t):
		return tree(label(t)*2)
	else:
		double_childrens = []
		for c in children(t):
			double_childrens.append(double(c))
		return tree(label(t)*2, doubled_children)
```

### Non-destructive verse. Destructive

- 就是是否修改原来的变量
- 设置一个可变的树

```python
def set_label(tree, label):
	tree[0] = label
def set_children(tree, children):
	tree[1] = children
```

- 复制列表

```python
listA = listB

listA = listB[:]
```

## Lecture 13: Recursive Objects

### A Tree Class

```python
class Tree:
	def __init__(self, label, branches=[]):
	"""Precondition: branches must be a list of Trees"""
		self.label = label
		for branch in branches:
			assert isinstance(branch,Tree)
		self.branches = list(branches)
	def is_leaf(self):
		return not self.branches 
	
	def __repr__(self):
		if self.branches:
			branch_str = ", "+ repr(self.branches)
		else:
			branch_str = ""
		return "Tree({0}{1})".format(self.label, branch_str)

	def __str__(self):
		return '\n'.join(self.indented())
	
	def indented(self):
		lines = []
		for b in self.branches:
			for line in b.indented():
				lines.append("*"+line)
		return [str(self.label)] + lines
```

### Link lists

```python
class Link:
	empty = ()
	def __init__(self, first, reset=empty):
		self.first = first
		self.rest = rest

def range_link(start, end):
	if start >= end:
		return Link.empty
	return Link(satrt, range_link(start+1, end))

def map_link(f, ll):
	if ll is Link.empty:
		return Link.empty
	return Link(f(ll.first), map_link(f, ll.rest))

def insert_front(linked_list, new_val):
	return Link(new_val, linked_list)

def inser_back(linked_list, new_val):
	return Link(linked_list.first,Link(new_val,linked_list.rest))

def add(ordered_list, new_val):
	if new_val < ordered_list.first:
		return Link(new_val, linked_list)
	elif new_val > ordered_list.first and ordered_list == Link.empty:
		ordered_list.rest = new_val
		return ordered_list
	elif new_val > ordered_list.first:
		return Link(ordered_list.first, add(ordered_list.rest, new_val))

```

## Lecture 14: Complexity

### Complexity

- 一般指时间复杂度或者空间复杂度，是指一个程序随着输入的规模增大与其消耗时间和占用内存之间的关系

```python
# 一个直接的方式是通过编写程序来记录该程序所消耗的时间

def fib(n):
	if n<= 1: return n
	else: return fib(n-1) + fib(n-2)

# timeit 是一个python内置的包可以用于计算一个程序的运行时间
from timeit import repeat
repeat('fib(10)', globals=globals(), number=5) # 重复计算fib(10)五次，global代表我们在哪个作用域中能够找到这个函数
[0.00029, 0.00027,0.00027...]
```

```bash
# 也可以通过命令行来完成这个工作
$ python3 -m timeit --setup='from fib import fib' 'fib(10)'
```

但是这只能给出一些特殊的例子，并不能告诉我们一般的程序究竟能够运行多快

```bash
# 也许可以通过一系列的时间去绘图来表示程序的运行速度
$ for t in 5 10 15 20 25 30; do
>    echo -n "$t:"
>    python3 -m timeit --setup='from fib import fib' "fib($t)"
>    done
5 2.04
10 22.5
15 256
...
```

### Worst case, Best case, average case

- 其实，复杂度可以理解成一个数学问题，对于计算一个函数$f(x)$，随着x的增加所消耗的计算时间不断变化的情况（例如，最坏情况、最好情况和平均情况（hard），最关注的是**最坏情况**）
- 困难在于如何将这一问题推广到所有的结果

```python
def near(L,x,delta):
	for y in L:
		if abs(y-x) <= delta:
			return True
	return False
```

我们对这个程序进行分析，可以发现这个程序运行的时间可以分解为如下几个部分：

- 一些固定的开销来开始运行
- 每次迭代所消耗的时间：abs() + __next+ ≤
- 结束循环时固定的开销
- 返回结果时固定的开销

随着迭代次数的增加，第二项所消耗的时间也会增加

$$
minfixedcost +M(L)\times minloopcost \leq C_{near}(L) \leq maxfixedcost +M(L)\times maxloopcost
$$

- 最坏的情况：$M(L)=len(L)$
- 最好的情况：$M(L)=0$

### The Notation

- 我们一般用$f(n)$来表示对于一个size为n的问题它的执行时间，我们用$\Theta(g(n))$来表示正比于$g(n)$的所有函数的集合
- 我们写$f(n) \in \Theta(g(n))$ 意思是无论n多大，$K_1|g(n)|\leq|f(n)|\leq K_2|g(n)|$，$f(n)和g(n)$成正比

![[complex.png|600]]

- 上面这条渐近线称为$\mathcal{O}$, 下面这条线称为$\Omega$

因此我们可以使用渐进分析来对`near`进行分析：

$$
minfc + N\times minlc \leq C_{near}^{WC} \leq  N\times maxlc
$$

假设我们忽略掉固定的常数，则：

$$
p\times N \leq C_{near}^{WC} \leq maxfc + q\times N \\

$$

$$
C_{near}^{WC} \in \Theta(N)
$$

| Bound on Worst case | Example |
| --- | --- |
| Constant Time   | x+=L[c] |
| Logarithmic Time | while N≥0: x, N = x+ L[N], N//2 |
| Linear Time  | for c in range(N): x+= L[c] |
| NlgN | def sort(L):
     M = len(L)//2
     if M ==0: return L
     else: return merge(sort(L[:M]), sort(L[M:])) |
| N**2 | for: for |
| x**N | Tree recrusion |
- 指数算法复杂度使得密码有效

所谓lower-bound result 是指针对问题P没有算法能够有一个小于$\Theta(f(n))$的渐进复杂度

## Lecture 15: Memoization

### How Fast Is This

```python
# 对于下面这个程序分析它的复杂度
for x in range(N):
	if L[x] < 0:
		c += 1
# \Theta(N) comparison
# \Theta(N) add

# 如果换一种形式：
for x in range(N):
	if L[x] < 0:
		c += 1
		break
# \Theta(N) comparison
# \Theta(1) add -- 执行一次就跳出循环

for x in range(2*N):
	f(x,x,x)
	for y in range(3*N):
		f(x,y,y)
		for z in range(4*N)
			f(x,y,z)

# 24*N^3+6N^2+2N -- 渐进复杂度分析N^2是N^3的高阶无穷小，所以可以化简为\Theta(N^3)

for x in range(N):
	for y in range(x):
		f(x,y)

# 0+1+2+...+N-1 ~ \Theta(N^2)

z=0
for x in range(N):
	for y in range(N):
		while z<N:
			f(x,y,z)
			z+=1
# \Theta(N) call of f 显而易见，因为z大于N就不调用了
# \Theta(N^2) comparisons

```

### New subject: avoiding Redundant Computation

```python
# 对于计算斐波那契数列，直接调用递归其实效率非常低
def fib(n):
	if n<= 1:
		return n
	a = 0
	b = 1
	for k in range(1,n+1):
		a,b = b, a+b
	return b

# 通过动态规划可以避免递归树中冗余部分的计算
```

### Change Counting

- 凑零钱问题：通过给定的零钱面值凑出一个数值，找到有多少种方法

```python
def count_change(amount, conins=(50,25,10,5,1)):
	if amount == 0:
		return 1
	elif amount <0 or len(coins)==0:
		return 0
	else:
		return count_change(amount-coins[0], coins)+count_change(amount, coins[1:)

# 我们对count_change做一些修改来改良其中可能产生的计算冗余

def count_change(amount, conins=(50,25,10,5,1)):
	memo_table = {}
	def count_change(amount, coins):
		key = (amount, coins)
		if key not in memo_table:
			memo_table[key]= full_count_change(amount, conins)
		return memo_table[key]
	def full_count_change(amount, conins):
		if amount == 0:
			return 1
		elif amount < 0 or len(conins)==0:
			return 0
		else:
			return count_change(amount-conins[0],coins)+count_change(amount,coins[1:])
	return count_change(amount,conins)
	
# 为什么没有得到无限递归（定义了边界条件）
	
def count_change(amount, conins=(50,25,10,5,1)):
	memo_table = [[-1]*len(conins)+1 for i in range(amount+1)] # 构建一个二维数组存储
	def count_change(amount, coins):
		if amount < 0: return 0
		elif memo_table[amount][len(conins)]==-1:
			memo_table[amount][len(conins)] = full_count_change(amount, conins)
		return memo_table[amount][len(conins)]
		
	def full_count_change(amount, conins):
		if amount == 0:
			return 1
		elif amount < 0 or len(conins)==0:
			return 0
		else:
			return count_change(amount-conins[0],coins)+count_change(amount,coins[1:])
	return count_change(amount,conins)
# 二维数组存储比字典索引要快很多，因为数组的存储空间是连续的，而字典的存储空间是不连续的

def count_change(amount, conins=(50,25,10,5,1)):
	memo_table = [[-1]*len(conins)+1 for i in range(amount+1)] # 构建一个二维数组存储
	def count_change(amount, coins):
		if amount < 0: return 0
		else: return memo_table[amount][len(conins)]
		
	def full_count_change(amount, conins):
		if amount == 0:
			return 1
		elif amount < 0 or len(conins)==0:
			return 0
		else:
			return count_change(amount-conins[0],coins)+count_change(amount,coins[1:])
	for a in range(0, amount+1):
		memo_table[a][0] = full_count_change(amount, ())
	for k in range(1, len(coins)+1):
		for a in range(0, amount+1):
			memo_table[a][k] = full_count_change(amount, conins[-k:)
			
	return count_change(amount,conins)
# 根据递归计算的顺序可以先生成memo_table,然后直接返回
```

## Lecture 16: Generics

### String formatting

```python
greeting = 'Ahoy'
noun = 'Boat'

print("%s, %syMc%sFace"%(greeting, noun, noun))

# 可读性不是很好

# 在python2.6 引入了str.format()方法

print('{},{}yMc{}Face'.format(greeting, noun, noun)) 
print('{0},{1}yMc{2}Face'.format(greeting, noun, noun)) 
print('{greeting},{noun}yMc{noun}Face'.format(greeting=greeting, noun=noun, noun=noun)) 
print(f'{greeting.upper()},{noun.lower()}yMc{noun[0]}Face')
# 保留两位小数
print(f'{greeting:.2f}'）
# 代表原始的字符串
print(r'{greeting:.2f}'）
```

### Generic

```python
# map是个强大的泛型函数，它不要求输入必须满足什么数据类型，而是针对不同的输入进行不同的运算
def map(items, func):
	mapped = []
	for item in items:
		mapped.append(func(item))
	return mapped

# 对于链表，由于没有定义__iter__无法调用

def __iter__(self):
	current = self
	while current is not Link.empty:
		yield current.first
		current = current.rest
# 这里其实将current改成self也可以，但这样代码的可读性会降低
# 修改self并不会影响数据结构本身，因为只是在局部作用域里修改
```

### Generic method names

| Method | Implements |
| --- | --- |
| _getitem_(s,k) | s[k] |
| __setitem_(s,k) | s[k] = v |
| _len_(s) | len(s) |
|  |  |

### Iterable
![[map.png|800]]
- 初次之外，python还可以通过定义`getitem`方法来进行迭代，当python找不到`iter`时就会找`getitem`，一直迭代直到超出`getitem`的边界

| function                 | description                                     |
| ------------------------ | ----------------------------------------------- |
| reversed(sequence)       | iterate over item in sequence in reversed order |
| zip(\*iterables)          | iterate over co-indexed tuples                  |
| map(func, iterable, ...) | func(x) for x in iterable                       |
| filter(func, iterable)   | same as map                                     |
|                          |                                                 |

- `sort(nums,key = lambda x: ...)`
- `all([True,True,True])`
- `any([False,False,True])`

## Lecture 17: Lisps & scheme

**lisp**语言最早是用于研究人工智能开发的处理符号的编程语言，scheme是lisp的一种方言，最大的特征是使用括号

- 并行编程时最好不要修改数据结构

`scheme` 数据可以分为`atoms` 和`pairs`

- 经典的Atoms:
    - 数值：整型、浮点数、复数、有理数
    - 符号（和字符串有点类似）
    - 布尔值：`#f` `#t`
    - 空列表：()
    - Procedures(function)
- pairs类似于python里的元组

### symbol

不仅包含数字和字母，还有一些其他的符号

### Programs

```scheme
(> 3 2) ; 3>2 ==> *t
(- (/(*(+ 3 7 10)(- 1000 8)) 992) 17) ; ((3+7+10) (1000-8))/992 - 17
(pair? (list 1 2)) ; ==> #t
```

scheme编程的优势在于已经完成了传统编译器的第一步，在python中首先需要将表达式字符串编译成语法树，但是对于scheme来说它已经是树了（逆波兰表达式）

### Quotation

- (quote E) 将E作为值返回，而不是将它作为一个`scheme`表达式：

```scheme
scm> (+ 1 2)
3
scm> (quote (+ 1 2))
(+ 1 2)
scm> '(+ 1 2)
(+ 1 2)
```

### special Forms

- `quote` 是一种特殊的形式，它不对表达式E求值，而是作为`quote E`的实际值返回
- if 也是一种特殊的形式: `(if (> x y) x y)`，类似于python中的if...else...
- `(and (integer? x) (> x y) (< x z))` 关键字 if
- `(or (not (integer? x)) (< x L) (> x U))` 关键字 or
- `lambda (x y) (/ (* x x) y)` 类似于python的lambda表达式
- `(define pi 3.1415926)`
- `(define (f x) (* x x))`

### Traditional Conditionals

```scheme
scm > (define x 5)
scm > (cond ((< x 1) 'small)
						((< x 3) 'median)
						((< x 5) 'large
						(#t      'big ))
```

```python
"small" if x<1 else "medium" if x<3 else "large" if x<5 else "big"
```

### symbol

scheme中可以定义symbol，一个symbol就像是一个变量名

```python
(define pi 3.1415926)
(define pi**2 (pi*pi))
```

### Function

```python
scm> ((lambda (x y) (+ (* x x) (* y y))) 3 4)
scm> (define fib
							(lambda (n) (if (n<2) n (+ (fib (- n 2)) (fib (- n 1))))))
scm> (fib 5)
5
scm> (define (fib n) 
							(if < n 2) n (+ (fib (- n 2)) (fib (- n 1))))
```

### Numbers

```scheme
scm> (quotient 3 2) ;整除
```

### Lists and Pairs

```scheme
scm> (cons 1 2) ; 构造列表
(1 . 2)         ; 这个点是什么东西？
scm> (cons 'a (cons 'b '()))
(a b)
scm> (define L '(a b c))
scm> (car L) ;L.first
a
scm> (cdr L) ;L.rest
(b c) 

;当然可以写成更简单的形式
scm> (list (+ 1 2) 'a 4)
```

### Equivalence Operations

```scheme
scm> (= 1 (- 2 1))
#t
scm> (eqv? 1 2)
#f
scm> (eqv? 1 (- 2 1))
#t
scm> (eqv? L '(1 2 3))
scm> (eq? L '(1 2 3))  ;类似python中的is
scm> (equal? L '(1 2 3)) ;可以深度做比较
```

### Binding Constructs: Let

```scheme
scm> (define x 17)
scm> (let ((x 5) ;创建局部变量x y  
					(y (+ x 2)))
					(+ x y))
```

### Loops and Tail Recursion

```scheme
;定义平方和函数
(define (sumsq n)
	(define (sunsq1 s n)
		(if (<= n 0) s 
				(sumsq1 (+ s (* n n)) 
											(- n 1))))
	(sumsq1 0 n))
(sumsq 1000)

```

### Translate to Scheme

```python
def count(predicate, L):
	if L is Link.empty():
		return 0
	elif predicate(L.first):
		return 1+ count(predicate, L.rest)
	else:
		return count(predicate, L.rest)
```

```scheme
(define (count predicate L)
	(cond ((eqv? L '()) 0)   
				((predicate (car L))
					(+ 1 (count predicate (cdr L))))
					(else (count predicate (cdr L))))
)
```

在Scheme中，尾递归作为迭代调用来执行，但是在这里由于在递归调用之后做了额外的判断，所以不是尾递归

```scheme

```

```scheme
(define (count predicate L) 
	(define (count1 L s) 
		(cond ((null? L) s)
					((predicate (car L)) (count1 (cdr L) (+ s 1)))
					(else (count1 (cdr L) s))))
	(count1 L 0)
	)

;else 也可以用#t 替代,表示进入该逻辑
```

### Another Function: Map

```python
def map(fn, L):
	if L is Link.empty():
		return L
	else:
		return Link(fn(L.first), map(fn,L.rest))
```

```scheme
(define (map fn L)
	(if (null? L) '()
			(cons (fn car(L)) (map fn cdr(L)))) ;(list <1> <2> <3>), (cons <1> (<2> <3>))
	)
```

修改为尾递归

```scheme
(define (map fn L)
		(define (loop list-so-far L) 
				(if (null? L) list-so-far
						(loop (append list-so-far (list (fn (car L)))) (cdr L))) ;创建一个比原来多一项的列表O(N**2)
)
		(loop '() L)
)
```

### Reverse

```scheme
(define (map fn L)
		(define (loop list-so-far L) 
				(if (null? L) list-so-far
						(loop (cons (fn (car L)) list-so-far) (cdr L))) ;(cons 2 '(1 3)) -> (2 1 3) 
)
		(reverse (loop '() L))
)

(define (reverse L)
		(define (reverse1 list-so-far L)
					(if (null? L) list-so-far
							(reverse1 (cons (car L) list-so-far)) cdr(L)))
		(reverse1 '() L)
 )
```

### Tree

```scheme
(define (tree label children) (cons label children))
(define (label tree) (car tree))
(define (children tree) (cdr tree))
(define (is-leaf tr) (null? (cdr tr)))
(define (double tr) (cons (* (car tree) 2) (cdr tree)))
```

## Lecture 18: Calculator

### Scheme projects

重要组件：

- 读取器，读取数据和程序 `scheme_read`
- 评估器，计算表达式 `scheme_eval`
    - buffer： 包含token lines → token_lines 转换成生成器，生成器中是一个字符串组成的列表的列表
    - apply: 接受函数和参数作为输入，并将这些参数应用到函数上。self-evaluating, function calls（计算scheme就是递归的调用apply）

```python
from scheme_token import tokenize_lines
from buffer import buffer
from scheme_reader import schme_read

L = tokenize_lines(["(define x", "(+ y 3)", "(define y 42)"]) # 储存为token化的列表（字符串列表的列表）
b = buffer(L)
scheme_read(b)
Pair('define', Pair('x', Pair(Pair("+", Pair("y", Pair(3, nil))), nil)))

```

**编译器**：将高级语言翻译成机器语言

逆波兰表达式：出栈-入栈

所有的程序都可以写成树

## Lecture 19: Define Synax-Macros

有时候需要根据我们的需要对语言进行扩展，很多语言中提供了一种叫**宏**的东西

```python
# define NLUE 3
```

这些替换可以在C和C++中通过预处理器在编译之前执行，宏定义只理解自己定义的指令

```python
# define defsym(x) x = #x
defsym(y) expands into y = "y" # 字符串化

#define doArray(var, A, low, high)\
	for(int var ## _index = low; var ## _index < high;\
			var ## _index += 1) {\
		int var = (A)[var ## _index];
#define endDo}

//定义后可以实现如下操作

doArray(p, anArray, 0, N)
	printf("Item %d is %d.\n",p_index,p)
endDo

#if defined(NDEBUG)
	#define assert(Test, Message)
#else
	#define assert(Test, Message) \
			if (!(Test)) {\
					fprintf(stderr,"%s\n", Message); \
					abort(1); \
//条件编译的一个例子
```

为什么要定义宏？是因为定义函数无法解决局部作用域里操作无效的问题，例如`swap`

```python
def swap(x,y):
	x,y = y,x

def swap(a[x], a[y]):
	a[x], a[y] = a[x], a[y]
```

`scheme`定义宏quasiquote

```scheme
(define L '(1 2 3))
scm> `(a b L)
(a b l)
scm> `(a b, L)
(a b (1 2 3))
scm> `(a b, @L)
(a b 1 2 3)
```

一个非常简单的例子

```scheme
>>>(define x 3)
>>>(unless (list? x) (displayln x))

;对此，可以定义宏
(define-macro (unless cond body))
	'(if (not ,cond), body)

(for-list x (* x x) L)

(define-marco (for-list var expr lst))
	`(map (lambda (,var) ,expr))

(for-range x 1 5 (* x x))

(define-macro (for-range control-var low high body)
	`((let ($low$ ,low))
		(define ($loop$ $so-far$ , control-var)
			(if (<, control-val $low$) $so-far$
				($loop$ (cons ,body $so-far$) (- ,control-var 1))))
($loop$ '() ,high)))
;实际执行的指令
(let (($low$ 1))
		(define ($loop$ $so-far$ x)
			(if (< x $low$) $so-far$
				($loop$ (cons (* x x) $so-far$) (- x 1))))
($loop$ '() 5))
```

宏是危险的，一般情况下尽量不使用宏，例如如果对一个变量进行了定义而且这个变量正好在宏里，那么可能会引发变量名替换的风险

## Lecture 20: Declarative Programming

**声明式编程**：给出需要生成的结果

命令式编程：命令式编程就是指通过代码指令去告诉你的电脑应该如何做某事

```python
logic> (query (add 2 3 ?z))
logic> (querry (add 2 3 5))
```

(详细需要看课本第4、5章)